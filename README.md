# slow5-template

This is a template repository that demonstrates how *slow5lib* can be used to develop a new nanopore signal analysis tool. Simply click on [use this template](https://github.com/hasindu2008/slow5-template/generate) button above, to create a new repository from this template.

## Compilation and running

```
git clone --recursive https://github.com/hasindu2008/slow5-template
cd slow5-template
make
./tool test/example.blow5
```
If you created your own project, remember to change the URL above and the repository name in the commands appropriately.

## Walkthrough

The repository contains the following:
1. [slow5lib](slow5lib) as a git submodule
1. A [Makefile](Makefile)
2. An example C programme [source file](src/main.c)
3. A simple [shell script](test/test.sh) for testing
4. A minimal [GitHub actions workflow](.github/workflows/c-cpp.yml)
5. Miscellaneous files such as license, .gitignore, etc

### slow5lib submodule

*slow5lib* has been added as a [submodule](slow5lib), which is like a link to the original *slow5lib* repository. You could checkout into a particular *slow5lib* version (v0.6.0 for example) as below:

```
cd slow5lib
git pull
git checkout v0.6.0
```

One you update the *slow5lib* version, you can commit this change:

```
cd ..
git add slow5lib
git commit -m "update slow5lib"
```

Optionally, if you do not prefer submodules, get rid of the submodule and copy paste only the necessary contents of slow5lib source code, as I have done in [sigtk](https://github.com/hasindu2008/sigtk/tree/main/slow5lib) or [f5c](https://github.com/hasindu2008/f5c/tree/master/slow5lib). While submodules make development easy, having the copy-pasted source code makes it easy to the user.

### Makefile

The [example make file](Makefile) has three main targets: 1, tool; 2, clean; and, 3, test.

When you invoke just `make`, the default target is to build the binary. The binary name (and the target name) is named as *tool* in this case and calling `make` is equivalent to calling `make tool`. When you call `make` or `make tool`, the objects defined on OBJ variable and *slow5lib* will be first compiled, followed by the linking step. *tool* target has a dependency (pre-requisites) to *slow5lib/lib/libslow5.a*, and the recipe for this target  will internally invoke `make -C slowlib` which will compile *slow5lib* by invoking the makefile inside slowlib/ to generate *slow5lib/lib/libslow5.a*.
Note that options such as *zstd* are passed to the slow5lib compilation command. So if you call *make zstd=1*, zstd=1 will be passed down to slow5lib compilation, consequently enable slow5lib with *zstd* compressed file support.

When you invoke `make clean`, the clean target will clean the binary, objects and call the makefile inside slow5lib to clean what was generated by slow5lib make.

When you invoke `make test`, the shell script at `test/test.sh` is called, that will run some basic tests.

This example makefile also can optionally called as `make asan=1` which will enable address santiser by adding relevant flags to the c-compiler (if you compiler supports it, gcc does). If you build your tool with address santiser enabled, when you run your tool it will run significantly slowly, but will show various memory leaks, memory overwrites, etc. While this example does not show, valgrind is another useful tool for debugging memory leaks, memory overwrites, etc.

There are some comments in the make file that shows what you have to do to change the name of the tool and to add more objects.

### C programme

The [example C programme source *main.c* under src/ directory](src/main.c) is a very basic example that demonstrates how slow5lib can be used to sequentially read a SLOW5/BLOW5 file and calculate the mean of pico-ampere converted signal for each read. You can modify this programme to what you want. When you project grows, add more files here as you wish in to the src/ directory and add them into the OBJ variable and as targets into the make file.

### Test shell script

The simple shell script under [test/test.sh](test/test.sh) executes the tool and performs a *diff* with the expected answer. If the execution of the tool or the diff fail, the script will exit with error. To this script, add more tests as you wish.

## GitHub workflow

A CI like GitHub actions is pretty useful for automatically testing on various environments. A [simple workflow configuration]((.github/workflows/c-cpp.yml)) has been provided that sets up two environments: ubuntu latest and MacOS. The workflow configurations will compile the project and will execute the *test.sh* script.

## Miscellaneous files

Make sure you change the [license](LICENSE) to what you want (which is MIT in this example) and also the year and name under copyright. An example [.gitignore](.gitignore) file has been added that contains common file extensions which we usually don't wanted to get accidentally commited. A [.gitattributes](.gitattributes) has been added so that any Windows newlines or MaCOS newlines are regularised into the Linux new line for certain file extensions. This useful when different people on different platforms are working on the project to prevent git-diff nightmares. Add/remove extensions to these .gitignore and .gitattributes files as you wish.





